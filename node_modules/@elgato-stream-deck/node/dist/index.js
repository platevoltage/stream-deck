"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamDeckProxy = exports.DeviceModelId = exports.VENDOR_ID = void 0;
exports.listStreamDecks = listStreamDecks;
exports.getStreamDeckDeviceInfo = getStreamDeckDeviceInfo;
exports.getStreamDeckInfo = getStreamDeckInfo;
exports.openStreamDeck = openStreamDeck;
const core_1 = require("@elgato-stream-deck/core");
const HID = require("node-hid");
const hid_device_js_1 = require("./hid-device.js");
const wrapper_js_1 = require("./wrapper.js");
const node_lib_1 = require("@elgato-stream-deck/node-lib");
var core_2 = require("@elgato-stream-deck/core");
Object.defineProperty(exports, "VENDOR_ID", { enumerable: true, get: function () { return core_2.VENDOR_ID; } });
Object.defineProperty(exports, "DeviceModelId", { enumerable: true, get: function () { return core_2.DeviceModelId; } });
Object.defineProperty(exports, "StreamDeckProxy", { enumerable: true, get: function () { return core_2.StreamDeckProxy; } });
/**
 * Scan for and list detected devices
 */
async function listStreamDecks() {
    const devices = {};
    for (const dev of await HID.devicesAsync()) {
        if (dev.path && !devices[dev.path]) {
            const info = getStreamDeckDeviceInfo(dev);
            if (info)
                devices[dev.path] = info;
        }
    }
    return Object.values(devices);
}
/**
 * If the provided device is a streamdeck, get the info about it
 */
function getStreamDeckDeviceInfo(dev) {
    const model = core_1.DEVICE_MODELS.find((m) => m.productIds.includes(dev.productId));
    if (model && dev.vendorId === core_1.VENDOR_ID && dev.path) {
        return {
            model: model.id,
            path: dev.path,
            serialNumber: dev.serialNumber,
        };
    }
    else {
        return null;
    }
}
/**
 * Get the info of a device if the given path is a streamdeck
 */
async function getStreamDeckInfo(path) {
    const allDevices = await listStreamDecks();
    return allDevices.find((dev) => dev.path === path);
}
/**
 * Open a streamdeck
 * @param devicePath The path of the device to open.
 * @param userOptions Options to customise the device behvaiour
 */
async function openStreamDeck(devicePath, userOptions) {
    // Clone the options, to ensure they dont get changed
    const jpegOptions = userOptions?.jpegOptions
        ? { ...userOptions.jpegOptions }
        : undefined;
    const options = {
        encodeJPEG: async (buffer, width, height) => (0, node_lib_1.encodeJPEG)(buffer, width, height, jpegOptions),
        ...userOptions,
    };
    let device;
    try {
        const hidDevice = await HID.HIDAsync.open(devicePath);
        device = new hid_device_js_1.NodeHIDDevice(hidDevice);
        const deviceInfo = await device.getDeviceInfo();
        const model = core_1.DEVICE_MODELS.find((m) => deviceInfo.vendorId === core_1.VENDOR_ID && m.productIds.includes(deviceInfo.productId));
        if (!model) {
            throw new Error('Stream Deck is of unexpected type.');
        }
        const rawSteamdeck = model.factory(device, options);
        return new wrapper_js_1.StreamDeckNode(rawSteamdeck, userOptions?.resetToLogoOnClose ?? false);
    }
    catch (e) {
        if (device)
            await device.close().catch(() => null); // Suppress error
        throw e;
    }
}
//# sourceMappingURL=index.js.map