"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamDeckNeoLcdService = void 0;
const headerGenerator_js_1 = require("../imageWriter/headerGenerator.js");
const imageWriter_js_1 = require("../imageWriter/imageWriter.js");
const util_js_1 = require("../../util.js");
class StreamDeckNeoLcdService {
    #encodeJPEG;
    #device;
    #lcdControls;
    #lcdImageWriter = new imageWriter_js_1.StreamdeckDefaultImageWriter(new headerGenerator_js_1.StreamdeckNeoLcdImageHeaderGenerator());
    constructor(encodeJPEG, device, lcdControls) {
        this.#encodeJPEG = encodeJPEG;
        this.#device = device;
        this.#lcdControls = lcdControls;
    }
    async fillLcdRegion(_index, _x, _y, _imageBuffer, _sourceOptions) {
        throw new Error('Not supported for this model');
    }
    async prepareFillLcdRegion(_index, _x, _y, _imageBuffer, _sourceOptions, _jsonSafe) {
        throw new Error('Not supported for this model');
    }
    async fillLcd(index, imageBuffer, sourceOptions) {
        const lcdControl = this.#lcdControls.find((control) => control.id === index);
        if (!lcdControl)
            throw new Error(`Invalid lcd segment index ${index}`);
        const imageSize = lcdControl.pixelSize.width * lcdControl.pixelSize.height * sourceOptions.format.length;
        if (imageBuffer.length !== imageSize) {
            throw new RangeError(`Expected image buffer of length ${imageSize}, got length ${imageBuffer.length}`);
        }
        // A lot of this drawing code is heavily based on the normal button
        const byteBuffer = await this.convertFillLcdBuffer(imageBuffer, lcdControl.pixelSize, sourceOptions);
        const packets = this.#lcdImageWriter.generateFillImageWrites(null, byteBuffer);
        await this.#device.sendReports(packets);
    }
    async clearLcdSegment(index) {
        const lcdControl = this.#lcdControls.find((control) => control.id === index);
        if (!lcdControl)
            throw new Error(`Invalid lcd segment index ${index}`);
        const buffer = new Uint8Array(lcdControl.pixelSize.width * lcdControl.pixelSize.height * 4);
        await this.fillLcd(index, buffer, {
            format: 'rgba',
        });
    }
    async clearAllLcdSegments() {
        const ps = [];
        for (const control of this.#lcdControls) {
            ps.push(this.clearLcdSegment(control.id));
        }
        await Promise.all(ps);
    }
    async convertFillLcdBuffer(sourceBuffer, size, sourceOptions) {
        const sourceOptions2 = {
            format: sourceOptions.format,
            offset: 0,
            stride: size.width * sourceOptions.format.length,
        };
        const byteBuffer = (0, util_js_1.transformImageBuffer)(sourceBuffer, sourceOptions2, { colorMode: 'rgba', xFlip: true, yFlip: true }, 0, size.width, size.height);
        return this.#encodeJPEG(byteBuffer, size.width, size.height);
    }
}
exports.StreamDeckNeoLcdService = StreamDeckNeoLcdService;
//# sourceMappingURL=neo.js.map