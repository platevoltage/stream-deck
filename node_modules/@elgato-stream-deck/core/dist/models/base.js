"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamDeckBase = void 0;
const eventemitter3_1 = require("eventemitter3");
const index_js_1 = require("../index.js");
const preparedBuffer_js_1 = require("../preparedBuffer.js");
class StreamDeckBase extends eventemitter3_1.EventEmitter {
    get CONTROLS() {
        return this.deviceProperties.CONTROLS;
    }
    // get KEY_SPACING_HORIZONTAL(): number {
    // 	return this.deviceProperties.KEY_SPACING_HORIZONTAL
    // }
    // get KEY_SPACING_VERTICAL(): number {
    // 	return this.deviceProperties.KEY_SPACING_VERTICAL
    // }
    get MODEL() {
        return this.deviceProperties.MODEL;
    }
    get PRODUCT_NAME() {
        return this.deviceProperties.PRODUCT_NAME;
    }
    get HAS_NFC_READER() {
        return this.deviceProperties.HAS_NFC_READER;
    }
    device;
    deviceProperties;
    // readonly #options: Readonly<Required<OpenStreamDeckOptions>>
    #propertiesService;
    #buttonsLcdService;
    #lcdSegmentDisplayService;
    #inputService;
    #encoderLedService;
    constructor(device, _options, services) {
        super();
        this.device = device;
        this.deviceProperties = services.deviceProperties;
        // this.#options = options
        this.#propertiesService = services.properties;
        this.#buttonsLcdService = services.buttonsLcd;
        this.#lcdSegmentDisplayService = services.lcdSegmentDisplay;
        this.#inputService = services.inputService;
        this.#encoderLedService = services.encoderLed;
        // propogate events
        services.events?.listen((key, ...args) => this.emit(key, ...args));
        this.device.on('input', (data) => this.#inputService.handleInput(data));
        this.device.on('error', (err) => {
            this.emit('error', err);
        });
    }
    checkValidKeyIndex(keyIndex, feedbackType) {
        const buttonControl = this.deviceProperties.CONTROLS.find((control) => control.type === 'button' && control.index === keyIndex);
        if (!buttonControl) {
            throw new TypeError(`Expected a valid keyIndex`);
        }
        if (feedbackType && buttonControl.feedbackType !== feedbackType) {
            throw new TypeError(`Expected a keyIndex with expected feedbackType`);
        }
    }
    calculateFillPanelDimensions(options) {
        return this.#buttonsLcdService.calculateFillPanelDimensions(options);
    }
    async close() {
        return this.device.close();
    }
    async getHidDeviceInfo() {
        return this.device.getDeviceInfo();
    }
    async setBrightness(percentage) {
        return this.#propertiesService.setBrightness(percentage);
    }
    async resetToLogo() {
        return this.#propertiesService.resetToLogo();
    }
    async getFirmwareVersion() {
        return this.#propertiesService.getFirmwareVersion();
    }
    async getAllFirmwareVersions() {
        return this.#propertiesService.getAllFirmwareVersions();
    }
    async getSerialNumber() {
        return this.#propertiesService.getSerialNumber();
    }
    async sendPreparedBuffer(buffer) {
        const packets = (0, preparedBuffer_js_1.unwrapPreparedBufferToBuffer)(this.deviceProperties.MODEL, buffer);
        await this.device.sendReports(packets);
    }
    async fillKeyColor(keyIndex, r, g, b) {
        this.checkValidKeyIndex(keyIndex, null);
        await this.#buttonsLcdService.fillKeyColor(keyIndex, r, g, b);
    }
    async fillKeyBuffer(keyIndex, imageBuffer, options) {
        this.checkValidKeyIndex(keyIndex, 'lcd');
        await this.#buttonsLcdService.fillKeyBuffer(keyIndex, imageBuffer, options);
    }
    async prepareFillKeyBuffer(keyIndex, imageBuffer, options, jsonSafe) {
        return this.#buttonsLcdService.prepareFillKeyBuffer(keyIndex, imageBuffer, options, jsonSafe);
    }
    async fillPanelBuffer(imageBuffer, options) {
        await this.#buttonsLcdService.fillPanelBuffer(imageBuffer, options);
    }
    async prepareFillPanelBuffer(imageBuffer, options, jsonSafe) {
        return this.#buttonsLcdService.prepareFillPanelBuffer(imageBuffer, options, jsonSafe);
    }
    async clearKey(keyIndex) {
        this.checkValidKeyIndex(keyIndex, null);
        await this.#buttonsLcdService.clearKey(keyIndex);
    }
    async clearPanel() {
        const ps = [];
        ps.push(this.#buttonsLcdService.clearPanel());
        if (this.#lcdSegmentDisplayService)
            ps.push(this.#lcdSegmentDisplayService.clearAllLcdSegments());
        await Promise.all(ps);
    }
    async fillLcd(...args) {
        if (!this.#lcdSegmentDisplayService)
            throw new Error('Not supported for this model');
        return this.#lcdSegmentDisplayService.fillLcd(...args);
    }
    async fillLcdRegion(...args) {
        if (!this.#lcdSegmentDisplayService)
            throw new Error('Not supported for this model');
        return this.#lcdSegmentDisplayService.fillLcdRegion(...args);
    }
    async prepareFillLcdRegion(...args) {
        if (!this.#lcdSegmentDisplayService)
            throw new Error('Not supported for this model');
        return this.#lcdSegmentDisplayService.prepareFillLcdRegion(...args);
    }
    async clearLcdSegment(...args) {
        if (!this.#lcdSegmentDisplayService)
            throw new Error('Not supported for this model');
        return this.#lcdSegmentDisplayService.clearLcdSegment(...args);
    }
    async setEncoderColor(...args) {
        if (!this.#encoderLedService)
            throw new Error('Not supported for this model');
        return this.#encoderLedService.setEncoderColor(...args);
    }
    async setEncoderRingSingleColor(...args) {
        if (!this.#encoderLedService)
            throw new Error('Not supported for this model');
        return this.#encoderLedService.setEncoderRingSingleColor(...args);
    }
    async setEncoderRingColors(...args) {
        if (!this.#encoderLedService)
            throw new Error('Not supported for this model');
        return this.#encoderLedService.setEncoderRingColors(...args);
    }
    async getChildDeviceInfo() {
        const info = await this.device.getChildDeviceInfo();
        if (!info || info.vendorId !== index_js_1.VENDOR_ID)
            return null;
        const model = index_js_1.DEVICE_MODELS.find((m) => m.productIds.includes(info.productId));
        if (!model)
            return null;
        return {
            ...info,
            model: model.id,
        };
    }
}
exports.StreamDeckBase = StreamDeckBase;
//# sourceMappingURL=base.js.map