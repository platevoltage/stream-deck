"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.wrapBufferToPreparedBuffer = wrapBufferToPreparedBuffer;
exports.unwrapPreparedBufferToBuffer = unwrapPreparedBufferToBuffer;
function wrapBufferToPreparedBuffer(modelId, type, buffers, jsonSafe) {
    let encodedBuffers = buffers;
    if (jsonSafe) {
        // Use Base64 encoding for binary-safe string conversion
        if (typeof Buffer !== 'undefined') {
            encodedBuffers = buffers.map((b) => Buffer.from(b).toString('base64'));
        }
        else {
            encodedBuffers = buffers.map((b) => btoa(String.fromCharCode(...b)));
        }
    }
    return {
        if_you_change_this_you_will_break_everything: 'This is a encoded form of the buffer, exactly as the Stream Deck expects it. Do not touch this object, or you can crash your stream deck',
        modelId,
        type,
        do_not_touch: encodedBuffers,
    };
}
function unwrapPreparedBufferToBuffer(modelId, 
// type: string,
prepared) {
    const preparedInternal = prepared;
    if (preparedInternal.modelId !== modelId)
        throw new Error('Prepared buffer is for a different model!');
    // if (preparedInternal.type !== type) throw new Error('Prepared buffer is for a different type!')
    return preparedInternal.do_not_touch.map((b) => {
        if (typeof b === 'string') {
            // Decode from Base64 for binary-safe conversion
            if (typeof Buffer !== 'undefined') {
                // Fast path for Node.js
                return Buffer.from(b, 'base64');
            }
            else {
                // Browser fallback
                return new Uint8Array(atob(b)
                    .split('')
                    .map((char) => char.charCodeAt(0)));
            }
        }
        else if (b instanceof Uint8Array) {
            return b;
        }
        else {
            throw new Error('Prepared buffer is not a string or Uint8Array!');
        }
    });
}
//# sourceMappingURL=preparedBuffer.js.map