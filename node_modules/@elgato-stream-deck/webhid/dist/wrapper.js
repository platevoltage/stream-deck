"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamDeckWeb = void 0;
const core_1 = require("@elgato-stream-deck/core");
/**
 * A StreamDeck instance.
 * This is an extended variant of the class, to provide some more web friendly helpers, such as accepting a canvas
 */
class StreamDeckWeb extends core_1.StreamDeckProxy {
    hid;
    constructor(device, hid) {
        super(device);
        this.hid = hid;
    }
    /**
     * Instruct the browser to close and forget the device. This will revoke the website's permissions to access the device.
     */
    async forget() {
        await this.hid.forget();
    }
    async fillKeyCanvas(keyIndex, canvas) {
        // this.checkValidKeyIndex(keyIndex)
        const ctx = canvas.getContext('2d');
        if (!ctx)
            throw new Error('Failed to get canvas context');
        const control = this.CONTROLS.find((control) => control.type === 'button' && control.index === keyIndex);
        if (!control || control.feedbackType === 'none')
            throw new TypeError(`Expected a valid keyIndex`);
        if (control.feedbackType !== 'lcd')
            throw new TypeError(`keyIndex ${control.index} does not support lcd feedback`);
        const data = ctx.getImageData(0, 0, control.pixelSize.width, control.pixelSize.height);
        return this.device.fillKeyBuffer(keyIndex, data.data, { format: 'rgba' });
    }
    async fillPanelCanvas(canvas) {
        const ctx = canvas.getContext('2d');
        if (!ctx)
            throw new Error('Failed to get canvas context');
        const dimensions = this.device.calculateFillPanelDimensions();
        if (!dimensions)
            throw new Error('Panel does not support filling');
        const data = ctx.getImageData(0, 0, dimensions.width, dimensions.height);
        return this.device.fillPanelBuffer(data.data, { format: 'rgba' });
    }
}
exports.StreamDeckWeb = StreamDeckWeb;
//# sourceMappingURL=wrapper.js.map