"use strict";
/* eslint-disable n/no-unsupported-features/node-builtins */
Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamDeckWeb = exports.StreamDeckProxy = exports.DeviceModelId = exports.VENDOR_ID = void 0;
exports.requestStreamDecks = requestStreamDecks;
exports.getStreamDecks = getStreamDecks;
exports.openDevice = openDevice;
const core_1 = require("@elgato-stream-deck/core");
const hid_device_js_1 = require("./hid-device.js");
const jpeg_js_1 = require("./jpeg.js");
const wrapper_js_1 = require("./wrapper.js");
var core_2 = require("@elgato-stream-deck/core");
Object.defineProperty(exports, "VENDOR_ID", { enumerable: true, get: function () { return core_2.VENDOR_ID; } });
Object.defineProperty(exports, "DeviceModelId", { enumerable: true, get: function () { return core_2.DeviceModelId; } });
Object.defineProperty(exports, "StreamDeckProxy", { enumerable: true, get: function () { return core_2.StreamDeckProxy; } });
var wrapper_js_2 = require("./wrapper.js");
Object.defineProperty(exports, "StreamDeckWeb", { enumerable: true, get: function () { return wrapper_js_2.StreamDeckWeb; } });
/**
 * Request the user to select some streamdecks to open
 * @param userOptions Options to customise the device behvaiour
 */
async function requestStreamDecks(options) {
    // TODO - error handling
    const browserDevices = await navigator.hid.requestDevice({
        filters: [
            {
                vendorId: core_1.VENDOR_ID,
            },
        ],
    });
    return Promise.all(browserDevices.map(async (dev) => openDevice(dev, options)));
}
/**
 * Reopen previously selected streamdecks.
 * The browser remembers what the user previously allowed your site to access, and this will open those without the request dialog
 * @param options Options to customise the device behvaiour
 */
async function getStreamDecks(options) {
    const browserDevices = await navigator.hid.getDevices();
    const validDevices = browserDevices.filter((d) => d.vendorId === core_1.VENDOR_ID);
    const resultDevices = await Promise.all(validDevices.map(async (dev) => openDevice(dev, options).catch((_) => null)));
    return resultDevices.filter((v) => !!v);
}
/**
 * Open a StreamDeck from a manually selected HIDDevice handle
 * @param browserDevice The unopened browser HIDDevice
 * @param userOptions Options to customise the device behvaiour
 */
async function openDevice(browserDevice, userOptions) {
    const model = core_1.DEVICE_MODELS.find((m) => browserDevice.vendorId === core_1.VENDOR_ID && m.productIds.includes(browserDevice.productId));
    if (!model) {
        throw new Error('Stream Deck is of unexpected type.');
    }
    await browserDevice.open();
    try {
        const options = {
            encodeJPEG: jpeg_js_1.encodeJPEG,
            ...userOptions,
        };
        const browserHid = new hid_device_js_1.WebHIDDevice(browserDevice);
        const device = model.factory(browserHid, options || {});
        return new wrapper_js_1.StreamDeckWeb(device, browserHid);
    }
    catch (e) {
        await browserDevice.close().catch(() => null); // Suppress error
        throw e;
    }
}
//# sourceMappingURL=index.js.map